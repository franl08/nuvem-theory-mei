<!DOCTYPE HTML>
<html lang="pt" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Teóricas de ASCN</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Teórica 01</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Teórica 02</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Teórica 03</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> Teórica 04</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">5.</strong> Teórica 05</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">6.</strong> Teórica 06</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">7.</strong> Teórica 07</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">8.</strong> Teórica 08</a></li><li class="chapter-item expanded "><a href="chapter_9.html"><strong aria-hidden="true">9.</strong> Teórica 09</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">10.</strong> Teórica 10</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Teóricas de ASCN</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="teórica-01"><a class="header" href="#teórica-01">Teórica 01</a></h1>
<p>Tem por objetivo responder à questão <strong>&quot;Como pôr aplicações e serviços a correr?&quot;</strong>.</p>
<p><strong>Desafios</strong></p>
<ul>
<li>Instalação
<ul>
<li>Múltiplos componentes com requisitos diferentes;</li>
<li>Hardware heterogéneo.</li>
</ul>
</li>
<li>Configuração e controlo</li>
<li>Monitorização do serviço constante.</li>
</ul>
<p><em><strong>Infrastructure as a code</strong></em></p>
<ul>
<li><em>Hardware</em>/<em>Software</em>/Configurações com <em>scripts</em>;</li>
<li><em>Scripts</em> podem ser utilizados nos processos <em>Agile</em> para replicar as condições desejadas.</li>
</ul>
<p><strong>Tópicos</strong></p>
<ol>
<li>Arquiteturas de sistemas distribuídos e <em>deployment</em>;</li>
<li><em>Cloud Computing</em>;</li>
<li>Monitorização e avaliação.</li>
</ol>
<p><strong>Agenda</strong></p>
<ul>
<li><strong>Projeto (50%)</strong>
<ul>
<li>Mínimo de 10 valores;</li>
<li>Entrega do Relatório: 14/01/23;</li>
<li>Apresentação: 16/01/23 até 20/01/23.</li>
</ul>
</li>
<li><strong>Teste (50%)</strong> 
<ul>
<li>Mínimo de 8 valores;</li>
<li>07/01/2023.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="teórica-02"><a class="header" href="#teórica-02">Teórica 02</a></h1>
<h2 id="aplicações-distribuídas"><a class="header" href="#aplicações-distribuídas">Aplicações Distribuídas</a></h2>
<h3 id="porquê-usá-las"><a class="header" href="#porquê-usá-las">Porquê usá-las?</a></h3>
<ul>
<li>Modularidade;</li>
<li>Desempenho;</li>
<li>Disponibilidade/Resiliência.</li>
</ul>
<h3 id="sistemas-monolíticos"><a class="header" href="#sistemas-monolíticos">Sistemas Monolíticos</a></h3>
<p>Múltiplos serviços para múltiplos alvos, mas tudo a correr numa única máquina... Ou seja, tipos de sistemas não distribuídos.</p>
<p><strong>Desvantagens:</strong></p>
<ul>
<li>Ponto de falha único;</li>
<li>Carga não é distribuída, o que provoca um ponto de contenção;</li>
<li>Os serviços não são isolados.</li>
</ul>
<p>Tipicamente, queremos ter estas 3 garantias nos nossos serviços:</p>
<h4 id="replicação"><a class="header" href="#replicação">Replicação</a></h4>
<ul>
<li>Múltiplas cópias dos mesmos dados e funcionalidades;</li>
<li>Providencia resiliência e, no caso de permitir que um cliente se conecte a outro servidor, poder de escala.</li>
</ul>
<h4 id="particionamento"><a class="header" href="#particionamento">Particionamento</a></h4>
<p>No caso de particionar apenas os dados, podemos dar-lhe o nome de <em>sharding</em>.</p>
<ul>
<li>O servidor é divido horizontalmente (<em>sharding</em>);</li>
<li>Oferece poder de escalabilidade;</li>
<li>Pode ser aplicado a computação, dados, etc...</li>
</ul>
<h4 id="arquitetura-orientada-aos-serviços-soa"><a class="header" href="#arquitetura-orientada-aos-serviços-soa">Arquitetura Orientada aos Serviços (SOA)</a></h4>
<p>Cada componente da aplicação deve correr num servidor diferente.</p>
<ul>
<li>Divide o servidor de forma vertical;</li>
<li>Providencia escalabilidade e modularidade;</li>
<li>Isto pode causar problemas na decomposição de serviços:
<ul>
<li><em>Quão micro deve ser?</em>;</li>
</ul>
</li>
<li>Tem um <em>deploy</em> complexo.</li>
</ul>
<h4 id="nota"><a class="header" href="#nota">Nota:</a></h4>
<ul>
<li><strong>Escala Vertical</strong>: Para escalar, podemos aumentar os recursos do <em>server</em>;</li>
<li><strong>Escala Horizontal</strong>: Para escalar, podemos aumentar o número de servidores.</li>
</ul>
<h3 id="arquiteturas-distribuídas"><a class="header" href="#arquiteturas-distribuídas">Arquiteturas Distribuídas</a></h3>
<p>Veja-se uns exemplos de arquiteturas distribuídas:</p>
<ul>
<li><em>Client-server</em>;</li>
<li>Servidor <em>proxy</em>;</li>
<li><em>Master-server</em>;</li>
<li><em>Server group</em>;</li>
<li><em>Multi-tier</em>;</li>
<li><em>Bus</em>.</li>
</ul>
<h4 id="client-server"><a class="header" href="#client-server"><em>Client-server</em></a></h4>
<ul>
<li>As funcionalidades e os dados encontram-se no servidor;</li>
<li>O cliente tem uma interface e fala com o servidor através de um protocolo num <em>stub</em>;
<ul>
<li>Um <em>stub</em> é um pacote de <em>middleware</em> presente no lado do cliente.</li>
</ul>
</li>
<li><strong>Desvantagens</strong>:
<ul>
<li>Ponto único de falha;</li>
<li>Gargalo na escalabilidade.</li>
</ul>
</li>
</ul>
<h4 id="proxy-server"><a class="header" href="#proxy-server"><em>Proxy Server</em></a></h4>
<ul>
<li>Adiciona-se um <em>proxy</em> entre o cliente e múltiplos <em>servers</em>;</li>
<li>Do lado do cliente é como se existisse um único servidor que é o <em>proxy</em>;</li>
<li><strong>Vantagens</strong>:
<ul>
<li>Permite o balanceamento do trabalho (maior escala e maior disponibilidade);</li>
</ul>
</li>
<li><strong>Desvantagens</strong>:
<ul>
<li>Ponto único de falha;
<ul>
<li>Não possui qualquer estado e tem um trabalho mais leve, o que provoca uma menor probabilidade de falha.</li>
</ul>
</li>
<li>Tem um número máximo de conexões simultâneas.</li>
</ul>
</li>
</ul>
<h4 id="master-server"><a class="header" href="#master-server"><em>Master Server</em></a></h4>
<p>Também conhecido por <em>Master-Slave</em>.</p>
<ul>
<li>Cliente entra em contacto com o <em>master</em> para saber onde se encontra o recurso pretendido;</li>
<li>Após saber onde é que o recurso pretendido se encontra, entra em contacto diretamente com o servidor.</li>
<li><strong>Vantagens</strong>:
<ul>
<li>Menos informação no ponto único de falha.</li>
</ul>
</li>
<li><strong>Desvantagens</strong>:
<ul>
<li>Ponto único de falha.</li>
</ul>
</li>
</ul>
<h4 id="server-group"><a class="header" href="#server-group"><em>Server Group</em></a></h4>
<ul>
<li>Todos os <em>servers</em> podem responder a pedidos;</li>
<li>Tem uma coordenação difícil;</li>
<li><strong>Vantagens</strong>:
<ul>
<li>Muito resiliente.</li>
</ul>
</li>
<li><strong>Desvantagens</strong>:
<ul>
<li>Muito pesado (o que provoca um baixo número de clientes) devido à lógica de balanceamento.</li>
</ul>
</li>
</ul>
<h4 id="bus"><a class="header" href="#bus"><em>Bus</em></a></h4>
<ul>
<li>Lógica de barramento;</li>
<li>Participantes produzem e consomem informação para o <em>bus</em>;</li>
<li>Um nó pode ser servidor <strong>e</strong> cliente;</li>
<li>Os participantes devem ter um protocolo comum entre si;</li>
<li><strong>Vantagens</strong>:
<ul>
<li>Altamente flexível.</li>
</ul>
</li>
</ul>
<h4 id="multi-tier"><a class="header" href="#multi-tier"><em>Multi-tier</em></a></h4>
<ul>
<li>Cada servidor atua como um cliente do nível inferior (ao estilo do modelo OSI);</li>
<li>Permite o <em>deploy</em> independente e o escalonamento de diferentes funcionalidades;</li>
<li>Cada camada tem um <em>stub</em> e protocolo para comunicar com a camada inferior;</li>
<li><strong>Vantagens</strong>:
<ul>
<li>Grande modularidade.</li>
</ul>
</li>
<li><strong>Desvantagens</strong>:
<ul>
<li>Muitos pontos únicos de falha.</li>
</ul>
</li>
</ul>
<p><strong>ATENÇÃO</strong>:</p>
<p>De forma a termos a melhor solução possível, podemos combinar diversas arquiteturas.</p>
<h4 id="estados-em-multi-tier"><a class="header" href="#estados-em-multi-tier">Estados em <em>multi-tier</em></a></h4>
<ul>
<li>Não há estados nas camadas superiores (p.e. <em>web server</em>);</li>
<li>Estados transientes/em cache nas camadas do meio;</li>
<li>Estados persistentes nas últimas camadas.
<ul>
<li><strong>Quanto mais para baixo se vai na pilha, mais complexa fica a replicação.</strong></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="teórica-03"><a class="header" href="#teórica-03">Teórica 03</a></h1>
<h2 id="serviços-de-cloud"><a class="header" href="#serviços-de-cloud">Serviços de <em>Cloud</em></a></h2>
<ul>
<li>Os serviços de <em>cloud</em> podem ser divididos em 3 abstrações principais:
<ul>
<li><strong><em>Infrastructure-as-a-Service</em> (IaaS)</strong>;</li>
<li><strong><em>Platform-as-a-Service</em> (PaaS)</strong>;</li>
<li><strong><em>Software-as-a-Service</em> (SaaS)</strong>.</li>
</ul>
</li>
</ul>
<h2 id="infrastructure-as-a-service-iaas"><a class="header" href="#infrastructure-as-a-service-iaas"><em>Infrastructure-as-a-Service</em> (IaaS)</a></h2>
<ul>
<li>
<p>Providencia recursos de <em>hardware</em> virtualizados como computação, armazenamento e <em>networking</em>;</p>
</li>
<li>
<p>Os recursos são alocados <em>on demand</em> e só se paga consoante o seu uso;</p>
</li>
<li>
<p>Exemplos:</p>
<ul>
<li>Para computação:
<ul>
<li><em>Amazon EC2</em>;</li>
<li><em>Google Compute Engine</em>.</li>
</ul>
</li>
<li>Para armazenamento:
<ul>
<li><em>Amazon S3</em>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Tem <em>data centers</em> espalhados pelo mundo, cada um com cerca de 80 000 servidores.</p>
</li>
</ul>
<h2 id="platform-as-a-service-paas"><a class="header" href="#platform-as-a-service-paas"><em>Platform-as-a-Service</em> (PaaS)</a></h2>
<ul>
<li>
<p>Oferece encapsulamento de um ambiente de desenvolvimento abstrato que pode ser usado para desenvoler, correr, ou dar <em>deploy</em> de <em>apps</em>.</p>
</li>
<li>
<p>Exemplo:</p>
<ul>
<li><em>Google App Engine</em>.</li>
</ul>
</li>
<li>
<p>Baseia-se em instâncias de <em>containers</em>;</p>
</li>
<li>
<p>Suporta múltiplas linguagens, ferramentas e APIs;</p>
</li>
<li>
<p>Providencia controlo de versões, testes, monitorização e <em>features</em> de <em>logging</em>.</p>
</li>
</ul>
<p><img src="images/paas.png" alt="image PaaS" /></p>
<h2 id="software-as-a-service-saas"><a class="header" href="#software-as-a-service-saas"><em>Software-as-a-Service</em> (SaaS)</a></h2>
<ul>
<li>Contém aplicações completas ou <em>software</em> genérico, tal como bases de dados;</li>
<li>Oferecido como um serviço e acessível através de um serviço <em>web</em> ou através de um <em>web browser</em>;</li>
<li>Exemplos:
<ul>
<li><em>SalesForce.com</em>;</li>
<li><em>Google Apps (p.e. Gmail)</em>.</li>
</ul>
</li>
</ul>
<p><img src="images/saas.png" alt="image SaaS" /></p>
<h2 id="openstack"><a class="header" href="#openstack"><em>OpenStack</em></a></h2>
<ul>
<li><em>Software Open-Source</em> que permitem a criação de <em>clouds</em> públicas e privadas;</li>
<li>Controla <em>pools</em> de computação, armazenamento e <em>networking</em> através de um <em>datacenter</em>;</li>
<li>Controlado através de uma <em>dashboard</em> ou via a API da <em>OpenStack</em>.</li>
</ul>
<h3 id="cinder"><a class="header" href="#cinder"><em>Cinder</em></a></h3>
<ul>
<li>Armazenamento em bloco
<ul>
<li>Virtualiza a gestão de dispositivos de blocos de armazenamento;</li>
<li>Fornece aos <em>end users</em> uma API de auto-serviço para pedir e consumir recursos sem ter conhecimento acerca da verdadeira localização ou do tipo de dispositivo em que se encontra o armazenamento.</li>
</ul>
</li>
</ul>
<h3 id="swift"><a class="header" href="#swift"><em>Swift</em></a></h3>
<ul>
<li>Grande disponibilidade, distribuídos, armazenamento de objetos/<em>blobs</em> eventualmente consistentes;</li>
<li>Ideal para guardar dados não estruturados que podem crescer sem fronteiras.</li>
</ul>
<h3 id="neutron"><a class="header" href="#neutron"><em>Neutron</em></a></h3>
<ul>
<li><em>Software-Defined-Network</em> (SDN)
<ul>
<li>Focado em fornecer <em>Networking-as-a-Service</em> (NaaS) em ambientes de computação virtuais;</li>
<li>Coloca a topologia da rede e o endereçamento de forma abstrata.</li>
</ul>
</li>
</ul>
<h3 id="telemetry"><a class="header" href="#telemetry"><em>Telemetry</em></a></h3>
<ul>
<li>Serviço de Monitorização
<ul>
<li>Coleciona métricas de monitorização para recursos físicos e virtuais;</li>
<li>Gera métricas para futura análise;</li>
<li>Dá <em>trigger</em> de ações quando atinge certas regras (p.e. lançar mais instâncias de uma dada VM quando um <em>threshold</em> de CPU é alcançado).</li>
</ul>
</li>
</ul>
<h2 id="de-iaas-para-paas"><a class="header" href="#de-iaas-para-paas">De IaaS para PaaS</a></h2>
<ul>
<li>De alocação gerida e provisionamento de recursos para infraestrutura gerida;</li>
<li>Recursos atuais tornam-se transparentes;</li>
<li>Foco na aplicação que é o objeto de <em>deploy</em>;</li>
<li>A interface é o ambiente de programação com APIs para serviços IaaS/SaaS;</li>
<li>O utilizador pode focar-se na funcionalidade para dar <em>deploy</em> ao invés dos recursos necessários para isso.</li>
</ul>
<h2 id="de-paas-para-saas"><a class="header" href="#de-paas-para-saas">De PaaS para SaaS</a></h2>
<ul>
<li>Providencia serviços específicos;</li>
<li>Gere componentes de <em>software</em> que exportam as suas APIs tradicionais;</li>
<li>Sistemas de Gestão de Bases de Dados são exemplos disto;</li>
<li>Não tem item de <em>deploy</em> - a BD está exposta através do cliente e é utilizada como uma BD tradicional com uma configuração mínima e acesso remoto.</li>
</ul>
<h2 id="iaas-paas-e-saas-sistemas-distribuídos-complexos"><a class="header" href="#iaas-paas-e-saas-sistemas-distribuídos-complexos">IaaS, PaaS e SaaS: sistemas distribuídos complexos</a></h2>
<ul>
<li>Virtualização;</li>
<li>Provisionamento;</li>
<li>Monitorização;</li>
<li><em>Reporting</em>;</li>
<li><em>Billing</em>;</li>
<li>...</li>
<li>Interoperação entre os pontos acima mencionados.</li>
</ul>
<h2 id="vantagens-iaas-paas-e-saas"><a class="header" href="#vantagens-iaas-paas-e-saas">Vantagens IaaS, PaaS e SaaS</a></h2>
<h3 id="conveniência"><a class="header" href="#conveniência">Conveniência</a></h3>
<ul>
<li><strong>IaaS</strong>
<ul>
<li>Evita custos <em>upfront</em> na gestão da infraestrutura e <em>hardware</em>;</li>
<li>Permite o <em>deploy</em> &quot;fácil&quot; de aplicações <em>legacy</em>.</li>
</ul>
</li>
<li><strong>PaaS</strong>
<ul>
<li>Foca-se no desenvolvimento da aplicação em si e nos seus requisitos;</li>
<li>Desenvolvimento, <em>deployment</em>, <em>debugging</em> e ferramentas de <em>benchmarking</em> <em>powerful</em> já no seu local.</li>
</ul>
</li>
<li><strong>SaaS</strong>
<ul>
<li>Aproveita componentes existentes (bases de dados, servidores de aplicação e servidores <em>web</em>).</li>
</ul>
</li>
</ul>
<h3 id="velocidade"><a class="header" href="#velocidade">Velocidade</a></h3>
<ul>
<li><strong>IaaS</strong>
<ul>
<li>Infraestrutura já se encontra instalada e configurada.</li>
</ul>
</li>
<li><strong>PaaS</strong>
<ul>
<li><em>Framework</em> de desenvolvimento já se encontra instalada e configurada.</li>
</ul>
</li>
<li><strong>SaaS</strong>
<ul>
<li>Rápida integração de soluções de <em>software</em> em <em>cloud</em>.</li>
</ul>
</li>
</ul>
<h3 id="elasticidade"><a class="header" href="#elasticidade">Elasticidade</a></h3>
<ul>
<li><strong>IaaS</strong>
<ul>
<li>Ilusão de recursos virtuais infinitos;</li>
<li>Aumento e diminuição do poder de computação, espaço de armazenamento e outros recursos <em>on demand</em>;
<ul>
<li>Precisa de ser configurado manualmente ou que se recorra a <em>apps third-party</em>.</li>
</ul>
</li>
</ul>
</li>
<li><strong>PaaS</strong> e <strong>SaaS</strong>
<ul>
<li>Não é necessário gerir a elasticidade manualmente.</li>
</ul>
</li>
</ul>
<h2 id="desvantagens-iaas-paas-e-saas"><a class="header" href="#desvantagens-iaas-paas-e-saas">Desvantagens IaaS, PaaS e SaaS</a></h2>
<h3 id="perda-de-controlo"><a class="header" href="#perda-de-controlo">Perda de Controlo</a></h3>
<ul>
<li><strong>IaaS</strong>
<ul>
<li>Perde-se o controlo sobre o <em>hardware</em> específico e o <em>software</em> de virtualização;</li>
<li>Sem possibilidade de <em>fine tuning</em> e otimização da infraestrutura.</li>
</ul>
</li>
<li><strong>PaaS</strong>
<ul>
<li>Sem controlo sob o <em>hardware</em> específico e da plataforma de PaaS;</li>
<li>Gestão, <em>fine tuning</em> e monitorização é reduzida às ferramentas providenciadas pela plataforma.</li>
</ul>
</li>
<li><strong>SaaS</strong>
<ul>
<li>Aplicações <em>cloud third-party</em>.</li>
</ul>
</li>
</ul>
<h3 id="segurança"><a class="header" href="#segurança">Segurança</a></h3>
<ul>
<li><strong>IaaS</strong>, <strong>PaaS</strong> e <strong>SaaS</strong>
<ul>
<li>Tão seguro como o providenciador \( \rightarrow \) qualquer vulnerabilidade do providenciador será uma vulnerabilidade da aplicação;</li>
<li>Correções às vulnerabilidades devem ser feitas diretamente no providenciador;</li>
<li>Se o providenciador falhar (mesmo que seja pouco provável), a aplicação falha e a recuperação está fora do controlo do dono da aplicação;</li>
<li>Privacidade dos dados em infraestruturas <em>third party</em>.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="teórica-04"><a class="header" href="#teórica-04">Teórica 04</a></h1>
<h2 id="aprovisionamento-de-sistema-system-provisioning"><a class="header" href="#aprovisionamento-de-sistema-system-provisioning">Aprovisionamento de Sistema (<em>System Provisioning</em>)</a></h2>
<h3 id="aprovisionamento"><a class="header" href="#aprovisionamento">Aprovisionamento</a></h3>
<p>Ação de providenciar, oferecer algo para uso.</p>
<p>Trata-se da configuração de servidores e recursos. Prepara o sistema para a fase de <em>deployment</em>.</p>
<p>Exemplos de ações:</p>
<ul>
<li>Aprovisionamento de Servidor;</li>
<li>Aprovisionamento de Armazenamento;</li>
<li>Aprovisionamento de Rede;</li>
<li>Aprovisionamento de VMs;</li>
<li>Aprovisionamento de Utilizadores.</li>
</ul>
<h3 id="deployment"><a class="header" href="#deployment"><em>Deployment</em></a></h3>
<p>Processo de instalar ou dar <em>upgrade</em> de uma aplicação ou serviço num servidor.</p>
<ul>
<li>Instalação ou <em>upgrade</em> de aplicações <em>web</em>:
<ul>
<li>Ficheiros;</li>
<li>Migrações;</li>
<li><em>Assets</em>.</li>
</ul>
</li>
<li>Instalação ou <em>upgrade</em> de serviços de rede;</li>
<li>O <em>scope</em> é o serviço ou a aplicação.</li>
</ul>
<h4 id="estas-2-etapas-são-muito-chatas"><a class="header" href="#estas-2-etapas-são-muito-chatas">Estas 2 etapas são muito chatas...</a></h4>
<ul>
<li>Processo repetitivo;
<ul>
<li>Bom para automação.</li>
</ul>
</li>
<li>Pode ter sistemas muito diferentes;
<ul>
<li>É preferível manter um inventário dos diferentes sistemas e correr as <em>tasks</em> de forma sequencial ou paralela.</li>
</ul>
</li>
<li>Provavelmente, terá ajustes ao longo do tempo;
<ul>
<li>Ter um controlo de versões pode ser muito positivo.</li>
</ul>
</li>
<li>Por vezes, pode consumir muito tempo.
<ul>
<li>Deixar a máquina a trabalhar sozinha pode ser muito positivo.</li>
</ul>
</li>
</ul>
<h3 id="gestão-de-configurações"><a class="header" href="#gestão-de-configurações">Gestão de Configurações</a></h3>
<p>Uma forma de controlar trocas sistemáticas no sistema mantendo a sua integridade ao longo do seu ciclo de vida.</p>
<ul>
<li>Configuração expressa num dialeto comum;</li>
<li>Resultado da configuração previsível;</li>
<li>Configuração evolui com a infraestrutura;</li>
<li>Documentação da infraestrutura como um efeito positivo;</li>
<li>Histórico completo de trocas quando é utilizado um sistema de gestão do <em>source code</em>;</li>
<li>Alterações são observáveis;</li>
<li>Automação do processo;</li>
<li>Cada unidade de trabalho é expressa como uma receita.</li>
</ul>
<h3 id="receitasreutilizaçãoautomação"><a class="header" href="#receitasreutilizaçãoautomação">Receitas/Reutilização/Automação</a></h3>
<p>Define automação de tarefas via um conjunto de diretivas expressas numa dada linguagem (p.e. <em>bash</em>).</p>
<p>Existem diversas ferramentas para ajudar neste processo:</p>
<p><img src="images/tools_recipes.png" alt="image Ferramentas" /></p>
<p>Nesta UC iremos utilizar <em><strong>Ansible</strong></em>.</p>
<p>O <em>workflow</em> passa a ser da seguinte forma:</p>
<p><img src="images/prov_deploy_workflow.png" alt="image Workflow" /></p>
<p><strong>NOTA:</strong>
<code>scp</code> é um comando <em>Unix</em> que permite copiar ficheiros entre servidores e máquinas locais.</p>
<h2 id="ansible"><a class="header" href="#ansible">Ansible</a></h2>
<h3 id="vocabulário"><a class="header" href="#vocabulário">Vocabulário</a></h3>
<ul>
<li><strong>Inventário</strong>:
<ul>
<li>Grupo dos alvos de <em>deployment</em>.</li>
</ul>
</li>
<li><strong>Módulo</strong>:
<ul>
<li>Unidade de trabalho reutilizável distribuída com <em>Ansible</em> ou desenvolvida para ele.</li>
</ul>
</li>
<li><em><strong>Task</strong></em>:
<ul>
<li>Combinação de módulos e argumentos de forma a efetuar uma dada ação.</li>
</ul>
</li>
<li><em><strong>Handlers</strong></em>:
<ul>
<li><em>Task</em> especial para responder a uma dada notificação.</li>
</ul>
</li>
<li><em><strong>Templates</strong></em>:
<ul>
<li>Permite a criação de configurações dinâmicas.</li>
</ul>
</li>
<li><em><strong>Role</strong></em>:
<ul>
<li>Componente configurável e reutilizável que encapsula variáveis, <em>templates</em>, <em>tasks</em>, <em>handlers</em>...</li>
</ul>
</li>
<li><em><strong>Playbook</strong></em>:
<ul>
<li>Descreve políticas para sistemas remotos.</li>
</ul>
</li>
</ul>
<h3 id="overview-do-ansible"><a class="header" href="#overview-do-ansible"><em>Overview</em> do <em>Ansible</em></a></h3>
<ul>
<li>Execução de receitas via <em>SSH</em> ou localmente sem a necessidade de agentes;</li>
<li>Receitas são expressas em ficheiros <em>YAML</em>;</li>
<li>Receitas criadas através de módulos e diretivas de <em>tasks</em>;</li>
<li>Receitas organizadas em <em>roles</em> e <em>playbooks</em>;</li>
<li><em>Hosts</em> alvo são definidos no inventário;</li>
<li>Idempotência.
<ul>
<li>Tarefas só correm no caso do alvo diferir daquilo que é expectável que aconteça depois de correr.</li>
</ul>
</li>
</ul>
<h3 id="exemplos-de-ficheiros"><a class="header" href="#exemplos-de-ficheiros">Exemplos de Ficheiros</a></h3>
<h4 id="inventário"><a class="header" href="#inventário">Inventário</a></h4>
<p>Tem extensão <code>.inv</code>. Por exemplo, <code>hosts.inv</code>:</p>
<pre><code>[host]
host-[01:99].example.com

[database]
db-01.example.com
staging.example.com
</code></pre>
<h4 id="playbook"><a class="header" href="#playbook"><em>Playbook</em></a></h4>
<pre><code>- hosts: all
  vars:
    username: someuser
    shell: /bin/bash
  tasks:
  - name: create unprivileged user
    user:
      name: '{{username}}'
      password: 'secretpasswordhash'
      shell: '{{shell}}'
  - name: Set SSH authorized_key
    authorized_key:
      user: '{{username}}'
      state: present
      key: &quot;{{ lookup('file', '/home/' + someuser + '/.ssh/id_rsa.pub') }}

</code></pre>
<p>Para mais informações acerca do <em>Ansible</em> deve consultar-se a sua documentação.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="teórica-05"><a class="header" href="#teórica-05">Teórica 05</a></h1>
<h2 id="virtualização"><a class="header" href="#virtualização">Virtualização</a></h2>
<ul>
<li>Técnica que permite criar algo virtual sobre um recurso;</li>
<li>A ideia é criar uma abstração sobre um recurso qualquer (<em>software</em> ou <em>hardware</em>);</li>
<li>Na <em>cloud</em>, falamos de virtualização a, praticamente, todos os níveis.</li>
</ul>
<p><strong>Exemplos</strong>:</p>
<ul>
<li>Redes Virtuais;</li>
<li>Memória Virtual;</li>
<li>Volumes de Armazenamento Lógicos.</li>
</ul>
<h3 id="vantagens"><a class="header" href="#vantagens">Vantagens</a></h3>
<h4 id="heterogeniedade"><a class="header" href="#heterogeniedade">Heterogeniedade</a></h4>
<ul>
<li>Recursos virtuais podem ser providenciados sob diferentes recursos de <em>hardware</em>;</li>
<li>Um recurso virtual poderá correr diferentes aplicações ou serviços utilizando o mesmo <em>hardware</em> (p.e. VMs a correrem em diferentes Sistemas Operativos).</li>
</ul>
<h4 id="transparência"><a class="header" href="#transparência">Transparência</a></h4>
<ul>
<li>A interação com uma VM, pela parte do utilizador, é semelhante à interação com uma máquina física.</li>
</ul>
<h4 id="isolamento"><a class="header" href="#isolamento">Isolamento</a></h4>
<ul>
<li>Os recursos virtuais são isolados uns dos outros em termos de:
<ul>
<li>Segurança;
<ul>
<li>Um cliente não sabe onde é que a máquina virtual se encontra a correr, nem que outras máquinas virtuais se encontram a correr naquele servidor.</li>
</ul>
</li>
<li>Desempenho;
<ul>
<li>Depende do componente em questão.</li>
</ul>
</li>
<li>Falhas (incluido sistemas operativos ou dados corrompidos).
<ul>
<li>A falha de 1 VM não afeta as restantes.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="otimização-de-recursos"><a class="header" href="#otimização-de-recursos">Otimização de Recursos</a></h4>
<ul>
<li>Os recursos físicos podem ser otimizados de forma a serem utilizados por diversos clientes.
<ul>
<li>Consolidação do Servidor;</li>
<li>Menos Custos.</li>
</ul>
</li>
</ul>
<h4 id="gestão--fácil"><a class="header" href="#gestão--fácil">Gestão + Fácil</a></h4>
<ul>
<li>A gestão de recursos virtuais é mais simples do que a gestão de recursos físicos.
<ul>
<li>Por exemplo, a migração e <em>backups</em> de VMs é muito mais fácil.</li>
</ul>
</li>
</ul>
<h3 id="desvantagens"><a class="header" href="#desvantagens">Desvantagens</a></h3>
<h4 id="desempenho"><a class="header" href="#desempenho">Desempenho</a></h4>
<ul>
<li>Geralmente, a virtualização de recursos traz uma <em>penalty</em> de desempenho associada.
<ul>
<li>Devido à &quot;tradução&quot; de pedidos lógicos para pedidos físicos.</li>
</ul>
</li>
</ul>
<h4 id="overprovisioning"><a class="header" href="#overprovisioning"><em>Overprovisioning</em></a></h4>
<ul>
<li>Dar <em>deploy</em> a mais recursos virtuais do que os disponíveis fisicamente pode gerar degradação de desempenho.</li>
</ul>
<h4 id="segurança-1"><a class="header" href="#segurança-1">Segurança</a></h4>
<ul>
<li>O isolamento pode não ser bem feito (p.e. mal endereçado);
<ul>
<li>Existem alguns <em>bugs</em> conhecidos nos <em>hypervisors</em>;</li>
</ul>
</li>
<li>Não oferece segurança contra quem acede diretamente ao servidor;
<ul>
<li>Num sistema tradicional, um atacante teria acesso a apenas 1 serviço, no entanto, neste tipo de sistemas, um atacante terá acesso a uma grande quantidade de serviços.</li>
</ul>
</li>
</ul>
<h4 id="resiliência"><a class="header" href="#resiliência">Resiliência</a></h4>
<ul>
<li>Se um servidor falhar, múltiplos serviços irão falhar.</li>
</ul>
<h3 id="máquinas-virtuais"><a class="header" href="#máquinas-virtuais">Máquinas Virtuais</a></h3>
<h4 id="porque-é-que-surgiram"><a class="header" href="#porque-é-que-surgiram">Porque é que surgiram?</a></h4>
<ul>
<li>Para permitir correr diferentes Sistemas Operativos em simultâneo no mesmo servidor físico;</li>
<li>Trocar uma aplicação/serviço para que este corra num Sistema Operativo diferente é uma tarefa difícil e custosa.</li>
</ul>
<h4 id="arquitetura"><a class="header" href="#arquitetura">Arquitetura</a></h4>
<ul>
<li>As instruções do <em>Guest OS</em> (isto é, da VM) são intercetadas, traduzidas e executadas no <em>hardware</em> físico.</li>
</ul>
<p><img src="images/arquitetura_vms.png" alt="image Arquitetura VMs" /></p>
<h5 id="hypervisor"><a class="header" href="#hypervisor"><em>Hypervisor</em></a></h5>
<ul>
<li>Também conhecido por VMM (<em>Virtual Machine Monitor</em>);</li>
<li>Controla a interação <em>low-level</em> entre as VMs e o sistema em que estas estão a correr;</li>
<li>Providencia acesso à CPU, RAM, disco e recursos de <em>hardware</em> de rede do <em>host</em>.</li>
</ul>
<h5 id="cpu-do-host"><a class="header" href="#cpu-do-host">CPU do <em>Host</em></a></h5>
<ul>
<li><em>Time Slicing</em> - o processamento de pedidos são divididos e partilhados ao longo das VMs;
<ul>
<li>Se tivermos vários <em>cores</em> \( \rightarrow \) utilização de 1 <em>core</em> por VM e evita-se este processo.</li>
</ul>
</li>
<li>Semelhante a correr múltiplos processos no <em>host</em>;</li>
<li>Dar <em>commitment</em> a demasiados <em>vCPUs</em> pode gerar a pior desempenho.</li>
</ul>
<h5 id="ram-e-armazenamento-persistente-do-host"><a class="header" href="#ram-e-armazenamento-persistente-do-host">RAM e Armazenamento Persistente do Host</a></h5>
<ul>
<li>Cada VM tem 1 parte de RAM e 1 parte de disco do <em>host</em> associada;</li>
<li>Não deverá interferir com a parte dos outros (tanto entre VMs, como com o <em>host</em>);
<ul>
<li>De forma a manter o isolamento entre recursos;</li>
<li>O <em>hypervisor</em> está responsável por não deixar o <em>host</em> interferir com a parte da VM.</li>
</ul>
</li>
<li>Armazenamento partilhado entre VMs poderá controlar múltiplos escritores/leitores eficientemente;</li>
<li>Recursos de Armazenamento podem ser alocados conforme pedido (isto é, <em>thin-provisioning</em>).</li>
</ul>
<h5 id="rede-do-host"><a class="header" href="#rede-do-host">Rede do <em>Host</em></a></h5>
<ul>
<li>As VMs partilham a largura de banda e podem ser configuradas com diferentes <em>setups</em> de rede:
<ul>
<li><em><strong>Host-only</strong></em>: Partilha a rede do <em>host</em> e só tem acesso ao <em>host</em>;</li>
<li><em><strong>NAT</strong></em>: Traduz o IP da VM para o IP do <em>host</em> e comunica com a rede exterior utilizando o IP do <em>host</em>. A comunicação da rede com a VM pode ser feita através de um protocolo de <em>forwarding</em> entre portas de rede;</li>
<li><em><strong>Bridge</strong></em>: Utiliza o <em>hypervisor</em> para obter um IP próprio para a VM. A VM é vista, na rede, como um nó de rede físico.</li>
</ul>
</li>
</ul>
<h3 id="modos-de-virtualização"><a class="header" href="#modos-de-virtualização">Modos de Virtualização</a></h3>
<h4 id="full-virtualization"><a class="header" href="#full-virtualization"><em>Full Virtualization</em></a></h4>
<ul>
<li>O <em>Guest OS</em> é tratado de uma forma completamente abstrata ao <em>hardware</em> do <em>host</em> em que está a correr (p.e. <em>VirtualBox</em>);</li>
<li><strong>Vantagem</strong>: Não efetuar modificações para o <em>Guest OS</em> funcionar indica que existe uma maior quantidade de Sistemas Operativos suportados e uma maior facilidade de migração e portabilidade de VMs;</li>
<li><strong>Desvantagem</strong>: Todas as instruções da VM têm de ser traduzidas no <em>hypervisor</em> o que poderá provocar uma queda de desempenho.
<ul>
<li>O <em>hardware</em> tem evoluído para combater isto. 
<ul>
<li>A introdução de <em>Hardware-Assisted Virtualization</em> (p.e. Intel VT-x, AMD-V) traz <em>hardware</em> específico para combater a <em>penalty</em> por tradução de instrução.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="paravirtualization"><a class="header" href="#paravirtualization"><em>Paravirtualization</em></a></h4>
<ul>
<li>Requere gatilhos/modificações ao Sistema Operativo da VM de forma a dar <em>bypass</em> às traduções de instruções custosas (p.e. <em>Xen</em>);</li>
<li><strong>Vantagem</strong>: Melhor <em>performance</em>, visto que não existe a tradução de instruções;</li>
<li><strong>Desvantangem</strong>: O Sistema Operativo do <em>Guest</em> tem de ser modificado, o que é pior para manutenção e portabilidade.</li>
</ul>
<h3 id="tipos-de-virtualização"><a class="header" href="#tipos-de-virtualização">Tipos de Virtualização</a></h3>
<h4 id="tipo-1---bare-metal-hypervisor"><a class="header" href="#tipo-1---bare-metal-hypervisor">Tipo 1 - <em>Bare Metal Hypervisor</em></a></h4>
<ul>
<li>O <em>Hypervisor</em> não precisa de Sistema Operativo de propósito geral no servidor de <em>host</em> (p.e. <em>VMWare ESX</em>);</li>
<li>O <em>Hypervisor</em> é <em>deployed</em> diretamente no <em>harware</em> como se fosse um Sistema Operativo de pequena dimensão;</li>
<li>Tem uma melhor <em>performance</em>, mas precisa de um suporte à virtualização específico no <em>hardware</em>, ou seja, é preciso <em>hardware</em> específico para correr isto.</li>
</ul>
<h4 id="tipo-2---hosted-hypervisor"><a class="header" href="#tipo-2---hosted-hypervisor">Tipo 2 - <em>Hosted Hypervisor</em></a></h4>
<ul>
<li>O <em>Hypervisor</em> é lançado num Sistema Operativo &quot;normal&quot; (p.e. <em>VirtualBox</em>);</li>
<li>Tem um pior desempenho, visto que o Sistema Operativo não é otimizado para virtualização;</li>
</ul>
<p><strong>Nota</strong></p>
<ul>
<li>O <em>KVM</em> e o <em>Xen</em> apresentam uma solução híbrida dos 2 tipos apresentados.
<ul>
<li>Os seus <em>hypervisors</em> precisam da instalação de módulos de <em>kernel</em> específicos em Sistemas Operativos &quot;normais&quot;.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="teórica-06"><a class="header" href="#teórica-06">Teórica 06</a></h1>
<h2 id="virtualização-1"><a class="header" href="#virtualização-1">Virtualização</a></h2>
<h3 id="containers"><a class="header" href="#containers"><em>Containers</em></a></h3>
<ul>
<li>Ambiente mais leve que permite ter aplicações a correr e ser bastante portável.
<ul>
<li>O Sistema Operativo não se encontra quebrado do <em>host</em>.
<ul>
<li>Ao invés disso, isola conjuntos de processos e recursos.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Porque é que são úteis?</strong>
<ul>
<li>Permitem correr diferentes versões da mesma aplicação na mesma máquina;</li>
<li>São fáceis de portar e de migrar;</li>
<li>A instalação é feita uma única vez.</li>
</ul>
</li>
</ul>
<h4 id="linux-containers"><a class="header" href="#linux-containers"><em>Linux Containers</em></a></h4>
<ul>
<li>São <strong>muito leves</strong> e não precisam da virtualização de recursos;</li>
<li>A <em>engine</em> isola e configura os recursos;</li>
<li>O sistema do <em>host</em> é compartimentado para cada <em>container</em> em termos de CPU e I/O;</li>
<li>Existe uma noção de isolamento entre <em>containers</em>.</li>
</ul>
<p><img src="images/vms_vs_containers.png" alt="image Máquinas Virtuais vs Containers" /></p>
<h5 id="building-blocks"><a class="header" href="#building-blocks"><em>Building Blocks</em></a></h5>
<ul>
<li><em><strong>Namespaces</strong></em> (Isolamento)
<ul>
<li>Ajudam a compartimentar grupos de processos, isto é, a que grupos cada <em>container</em> poderá aceder;</li>
<li>Permite a partilha de recursos do <em>host</em> entre diversos <em>containers</em> sem conflitos.</li>
</ul>
</li>
<li><em><strong>Control Groups</strong></em> (Gestão de Recursos)
<ul>
<li>Permite o alocamento de recursos entre grupos de processos;</li>
<li>Restringe a quantidade de recursos utilizada por cada <em>container</em>;</li>
<li>Um grupo de processos terá acesso a um recurso da máquina, no entanto, apenas poderá usar parte dele.</li>
</ul>
</li>
<li><em><strong>SELinux</strong></em> (Segurança)
<ul>
<li>Garante segurança de forma a que um <em>container</em> não seja capaz de interferir com outros <em>containers</em> ou com o sistema <em>host</em>;</li>
<li>Garante controlo de acesso e políticas de segurança.</li>
</ul>
</li>
</ul>
<h5 id="tipos"><a class="header" href="#tipos">Tipos</a></h5>
<ul>
<li><em><strong>OS Containers</strong></em>
<ul>
<li>Simulam um sistema operativo leve;</li>
<li>Exemplo: LXC.</li>
</ul>
</li>
<li><em><strong>Application Containers</strong></em>
<ul>
<li>Focado em empacator uma <em>app</em> e as suas definições;</li>
<li>Cada aplicação é vista como um processo independente;</li>
<li>Exemplo: Docker.</li>
</ul>
</li>
</ul>
<h3 id="docker"><a class="header" href="#docker">Docker</a></h3>
<p><img src="images/docker.png" alt="image Docker" /></p>
<h4 id="cliente-docker"><a class="header" href="#cliente-docker">Cliente Docker</a></h4>
<ul>
<li>Componente utilizada para interagir com a plataforma do Docker;</li>
<li>Envia pedidos para o Daemon (<em>engine</em>) do Docker;</li>
<li>Gere tudo aquilo que se possa fazer com o cliente;</li>
<li>Expõe a API do Docker para:
<ul>
<li>Correr e gerir <em>containers</em> e redes;</li>
<li>Leitura de <em>logs</em> e métricas;</li>
<li>Extração e gestão de imagens.</li>
</ul>
</li>
</ul>
<h4 id="daemon-do-docker"><a class="header" href="#daemon-do-docker">Daemon do Docker</a></h4>
<ul>
<li>Utiliza a API do Docker para receber pedidos do Cliente Docker;</li>
<li>Gere imagens do Docker, <em>Containers</em> e Redes.</li>
</ul>
<h4 id="objetos-do-docker"><a class="header" href="#objetos-do-docker">Objetos do Docker</a></h4>
<ul>
<li><em><strong>Image</strong></em> - ficheiro imutável que contém o <em>source code</em>, as bibliotecas e outros ficheiros necessários para uma dada aplicação correr;</li>
<li><em><strong>Container</strong></em> - instância <em>runnable</em> de uma <em>Image</em>.</li>
</ul>
<h4 id="registo-do-docker"><a class="header" href="#registo-do-docker">Registo do Docker</a></h4>
<ul>
<li>Repositório de imagens do Docker.</li>
</ul>
<h3 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h3>
<ul>
<li>Automatizam o <em>deployment</em>, o escalonamento e a gestão de <em>containers</em>;</li>
<li><strong>Garantias</strong>:
<ul>
<li>Gestão de redes;</li>
<li>Orquestração de armazenamento modular;</li>
<li>Agendamento, <em>self-healing</em> e escalonamento.</li>
</ul>
</li>
</ul>
<h4 id="cluster-de-kubernetes"><a class="header" href="#cluster-de-kubernetes"><em>Cluster</em> de Kubernetes</a></h4>
<ul>
<li>Os clientes interagem com o nodo <em>Master</em> (p.e. através do <code>kubectl</code> no terminal);</li>
<li>O nodo <em>Master</em> gere o <em>cluster</em> (p.e. nodos <em>worker</em>, <em>pods</em>, redes, armazenament, ...).</li>
</ul>
<p><img src="images/cluster_k8s.png" alt="image Cluster de Kubernetes" /></p>
<h5 id="pod-deployument-e-service"><a class="header" href="#pod-deployument-e-service"><em>Pod</em>, <em>Deployument</em> e <em>Service</em></a></h5>
<ul>
<li><em><strong>Pod</strong></em>: unidade computacional composta por um ou mais <em>containers</em>;</li>
<li><em><strong>Deployment</strong></em>: especifica o ambiente onde vão correr os <em>pods</em>;</li>
<li><em><strong>Service</strong></em>: expõe um grupo de <em>pods</em> como um serviço de rede.</li>
</ul>
<h5 id="rede"><a class="header" href="#rede">Rede</a></h5>
<ul>
<li>Cada <em>pod</em> tem um endereço de IP único no <em>cluster</em>;
<ul>
<li>As conexões entre <em>pods</em> (mesmo em nodo <em>worker</em> diferentes) pode ser gerida através dos <em>overlays</em> de redes.</li>
</ul>
</li>
</ul>
<h5 id="armazenamento"><a class="header" href="#armazenamento">Armazenamento</a></h5>
<ul>
<li>Os <em>pods</em> podem aceder a volumes de armazenamento providenciados por diferentes <em>backends</em> de armazenamento.
<ul>
<li><strong>Armazenamento Efémero</strong>: os dados sobrevivem apenas durante a sessão;</li>
<li><strong>Armazenamento Persistente</strong>: os dados sobrevivem mesmo após as sessões.</li>
</ul>
</li>
</ul>
<h3 id="containers-vs-máquinas-virtuais"><a class="header" href="#containers-vs-máquinas-virtuais"><em>Containers vs</em> Máquinas Virtuais</a></h3>
<ul>
<li>A escolha deve depender dos objetivos do utilizador! As diferentes soluções são melhores para diferentes cenários.
<ul>
<li>VMs são úteis quando é necessária uma virtualização <em>full server</em> (do Sistema Operativo);</li>
<li><em>Containers</em> são úteis para gerir diferentes bibliotecas/aplicações.</li>
</ul>
</li>
</ul>
<h4 id="vantagens-dos-containers"><a class="header" href="#vantagens-dos-containers">Vantagens dos <em>Containers</em></a></h4>
<ul>
<li>Mais rápidos;</li>
<li>Melhor utilização de recursos;</li>
<li>Podem ser lançadas em servidores virtualizados ou físicos.</li>
</ul>
<h4 id="desvantagens-dos-containers"><a class="header" href="#desvantagens-dos-containers">Desvantagens dos <em>Containers</em></a></h4>
<ul>
<li>Pior isolamento/segurança (Kernel e Sistema Operativo são partilhados);</li>
<li>Menor flexibilidade a correr em diferentes Sistemas Operativos.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="teórica-07"><a class="header" href="#teórica-07">Teórica 07</a></h1>
<h2 id="armazenamento-1"><a class="header" href="#armazenamento-1">Armazenamento</a></h2>
<ul>
<li><strong>Porque é que estes sistemas são importantes?</strong>
<ul>
<li>Ter dados armazenados, pesistentes e disponíveis;</li>
<li>Boa <em>performance</em>.</li>
</ul>
</li>
</ul>
<h3 id="tipos-1"><a class="header" href="#tipos-1">Tipos</a></h3>
<h4 id="arquivo"><a class="header" href="#arquivo">Arquivo</a></h4>
<ul>
<li>Cópias de coisas que tinha e que pretendo guardar;</li>
<li>Precisam de ser muito rápidos em termos de débito (a latência é praticamente irrelevante);</li>
<li>Padrão Sequencial;
<ul>
<li>Padrões aleatórios causam lentidão.</li>
</ul>
</li>
<li>Geralmente, só se irão escrever estes dados uma única vez.</li>
<li><strong>Exemplo</strong>: <em>Amazon Glacier</em> (serviço na <em>cloud</em>).</li>
</ul>
<h4 id="backup"><a class="header" href="#backup"><em>Backup</em></a></h4>
<ul>
<li>Precisam de ser muito rápidos em termos de débito;</li>
<li>Padrão Sequencial;</li>
<li>Em alguns casos, os dados podem ser atualizados;</li>
<li>Os dados são atualizados através de <em>diffs</em> (muito leves);
<ul>
<li>Em alguns casos, apenas os <em>diffs</em> são guardados entre <em>backups</em> da mesma fonte.</li>
</ul>
</li>
<li><strong>Exemplo</strong>: <em>Amazon S3</em> (serviço da <em>cloud</em>).</li>
</ul>
<h4 id="armazenamento-primário"><a class="header" href="#armazenamento-primário">Armazenamento Primário</a></h4>
<p>O armazenamento primário pode ser constituído não apenas pela RAM, como também por discos.</p>
<ul>
<li>Desejável que tenham grande débito e baixa latência;
<ul>
<li>Grandes quantidades de dados podem ser escritos/lidos;</li>
<li>Escritas/Leituras pequenas devem ser eficientes.</li>
</ul>
</li>
<li>Padrão Sequencial ou Aleatório;</li>
<li>Os dados e os metadados apresentam uma grande carga de trabalho;</li>
<li>Dados podem ser atualizados com frequência.</li>
<li><strong>Exemplo</strong>: <em>Amazon EBS</em> (serviço da <em>cloud</em>).</li>
</ul>
<h3 id="meios-de-armazenamento"><a class="header" href="#meios-de-armazenamento">Meios de Armazenamento</a></h3>
<ul>
<li><em>Tape</em>;
<ul>
<li>Armazenamento de Arquivo.</li>
</ul>
</li>
<li><em>HDD</em>;
<ul>
<li>Aramzenamento de Arquivo, <em>Backup</em> ou Primário.</li>
</ul>
</li>
<li><em>SSD</em> (incluindo <em>NVMe</em>);
<ul>
<li>Armazenamento Primário.</li>
</ul>
</li>
<li>Memória Persistente;
<ul>
<li>Armazenamento Primário.</li>
</ul>
</li>
<li>RAM.
<ul>
<li>Armazenamento Primário.</li>
</ul>
</li>
</ul>
<h3 id="interfaces-de-armazenamento"><a class="header" href="#interfaces-de-armazenamento">Interfaces de Armazenamento</a></h3>
<ul>
<li>
<p><em><strong>Block Device</strong></em>;</p>
<ul>
<li>Interface mais próxima do disco;</li>
<li>Os dados são geridos como blocos.</li>
<li>Exemplos: <em>iSCSI</em>, <em>Amazon EBS</em>, <em>Ceph</em>, ...</li>
</ul>
</li>
<li>
<p><strong>Sistema de Ficheiros</strong>:</p>
<ul>
<li>Dados são geridos como uma hierarquia de ficheiros.</li>
<li>Exemplos: <em>Ext4</em>, <em>Lustre</em>, <em>Ceph</em>, ...</li>
</ul>
</li>
<li>
<p><strong>Armazenamento por Objetos</strong>:</p>
<ul>
<li>Dados são geridos como objetos.</li>
<li>Exemplos: <em>Amazon S3</em>, <em>Openstack Swift</em>, <em>Ceph</em>.</li>
</ul>
</li>
<li>
<p>Muitas vezes, se uma aplicação está lenta pode ser devido à sua interação com o armazenamento.</p>
</li>
<li>
<p>O NFS é muito lento, mas muito utilizado na indústria.</p>
<ul>
<li>Só permite utilizar múltiplos dados num único servidor.</li>
</ul>
</li>
</ul>
<h3 id="scope"><a class="header" href="#scope">Scope</a></h3>
<h4 id="local"><a class="header" href="#local">Local</a></h4>
<ul>
<li><em>Block Devices</em> do Sistema Operativo;</li>
<li>Sistemas de Ficheiros do Sistema Operativo;</li>
<li><em>Kernel vs User Space</em>.</li>
</ul>
<p><img src="images/scope_local.png" alt="image Scope Local" /></p>
<h4 id="remoto"><a class="header" href="#remoto">Remoto</a></h4>
<ul>
<li><em>Block Devices</em> de Rede;</li>
<li>Sistemas de Ficheiros de Rede;</li>
<li>Paradigma Cliente-Servidor.</li>
</ul>
<p><img src="images/scope_remote.png" alt="image Scope Remote" /></p>
<h4 id="distribuído-data-centers"><a class="header" href="#distribuído-data-centers">Distribuído (<em>Data Centers</em>)</a></h4>
<ul>
<li>Grande Escala (ou seja, infraestruturas na <em>Cloud</em> e <em>HPC</em>);
<ul>
<li>Centenas a Milhares de Nodos;</li>
</ul>
</li>
<li><em>Churn</em> Estável;
<ul>
<li>Isto é, os nodos que entram e saem do sistema;</li>
<li>Mas os nodos podem falhar.</li>
</ul>
</li>
<li>Não há um ponto único de falha.
<ul>
<li>Dados distribuídos (replicados) entre nodos;</li>
<li>Metadados, tipicamente, são geridos por outros nodos.</li>
</ul>
</li>
<li>Exemplos: <em>HDFS</em>, <em>Ceph</em>, <em>Lustre</em>, <em>GPFS</em>.</li>
</ul>
<p><img src="images/scope_distributed.png" alt="image Scope Distributed" /></p>
<h4 id="altamente-distribuído-peer-to-peer"><a class="header" href="#altamente-distribuído-peer-to-peer">Altamente Distribuído (<em>Peer-to-Peer</em>)</a></h4>
<ul>
<li>Muito grande escala;
<ul>
<li>Milhares a milhões de nodos.</li>
</ul>
</li>
<li>Grande <em>churn</em>;
<ul>
<li>Nodos falham e são substituídos com frequência.</li>
</ul>
</li>
<li>Não há um ponto único de falha.
<ul>
<li>Dados e metadados distribuídos (replicados) entre nodos;</li>
<li>Diferentes nodos podem interagir com a aplicação do utilizador.</li>
</ul>
</li>
<li>Exemplos: <em>Napster</em>, <em>Gnutella</em>, <em>CFS</em>, <em>Farsite</em>, <em>DataFlasks</em>.</li>
</ul>
<p><img src="images/scope_highly_distributed.png" alt="image Scope Highly Distributed" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="teórica-08"><a class="header" href="#teórica-08">Teórica 08</a></h1>
<h2 id="armazenamento-2"><a class="header" href="#armazenamento-2">Armazenamento</a></h2>
<h3 id="funcionalidades"><a class="header" href="#funcionalidades">Funcionalidades</a></h3>
<h4 id="disponibilidade-de-dados"><a class="header" href="#disponibilidade-de-dados">Disponibilidade de Dados</a></h4>
<ul>
<li><strong>RAID</strong>: <em>Redundant Array of Inexpensive Drives</em>;</li>
<li>Replicação;</li>
<li><em>Erasure-Codes</em>.
<ul>
<li>Pega no ficheiro e parte em <em>k</em> blocos e <em>x</em> blocos de paridade.
<ul>
<li>Ocupa o espaço do ficheiro + \( \frac{1}{2} \) do tamanho do ficheiro;</li>
<li>Tolera mais falhas que a replicação.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="otimizações-de-performance"><a class="header" href="#otimizações-de-performance">Otimizações de <em>Performance</em></a></h4>
<ul>
<li>
<p><strong>Localidade de Dados</strong></p>
<ul>
<li>Tenta garantir que os dados estão o mais próximo possível dos nós que os estão a processar;</li>
<li>O armazenamento e o processamento encontram-se no mesmo dispositivo/servidor;</li>
<li><strong>Exemplos</strong>: <em>HBase</em> e <em>HDFS</em>, <em>active storage</em>.</li>
</ul>
</li>
<li>
<p><em><strong>Caching</strong></em></p>
<ul>
<li>Mantém os dados num armazenamento mais rápido, tipicamente em RAM;</li>
<li>Mantém os dados perto do cliente e/ou acessíveis a partir de uma origem rápida;</li>
<li>Evita a espera pela escrita/leitura de dados do armazenamento local/remoto;</li>
<li><strong>Exemplos</strong>: <em>file system page cache</em>, <em>Alluxio</em>.</li>
</ul>
</li>
</ul>
<h4 id="eficiência-de-espaço"><a class="header" href="#eficiência-de-espaço">Eficiência de Espaço</a></h4>
<ul>
<li>
<p><strong>Compressão</strong></p>
<ul>
<li>Reduz o conteúdo redundante entre e nos ficheiros;</li>
<li>Encontra conteúdo redundante num ficheiro ou conjunto de ficheiros e comprime-o;</li>
<li>Geralmente, é estático, no entanto, até quando é um processo dinâmico é mais lento que a deduplicação.</li>
</ul>
</li>
<li>
<p><strong>Deduplicação</strong></p>
<ul>
<li>Elimina as cópias redundantes num sistema de armazenamento;</li>
<li>Processo dinâmico.</li>
</ul>
</li>
</ul>
<h4 id="segurança-2"><a class="header" href="#segurança-2">Segurança</a></h4>
<ul>
<li>
<p><strong>Encriptação de Dados</strong></p>
<ul>
<li><em>Encryption at rest</em>:
<ul>
<li>Os dados são encriptados antes de serem guardados de forma persistente;</li>
<li>Os dados são encriptados quando chegam ao disco.</li>
</ul>
</li>
<li><em>Encryption in transit</em>:
<ul>
<li>Encripta os dados &quot;no caminho&quot; até ao disco.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Controlo de Acesso</strong></p>
<ul>
<li>Evita o acesso não autorizado de utilizadores aos dados.</li>
</ul>
</li>
</ul>
<h3 id="soluções-de-armazenamento-complexas-e-monolíticas"><a class="header" href="#soluções-de-armazenamento-complexas-e-monolíticas">Soluções de Armazenamento Complexas e Monolíticas</a></h3>
<ul>
<li>Para resolver um pedido é preciso passar por muitos componentes.
<ul>
<li>É difícil de dar <em>tracking</em>;</li>
<li>É difícil de otimizar.</li>
</ul>
</li>
<li>A combinação ideal de funcionalidades de armazenamento depende dos requisitos de cada aplicação:
<ul>
<li>Tamanho dos ficheiros;</li>
<li>Padrões de acesso ao armazenamento;</li>
<li>...</li>
</ul>
</li>
</ul>
<h3 id="software-defined-storage"><a class="header" href="#software-defined-storage"><em>Software-Defined Storage</em></a></h3>
<ul>
<li>Segue os príncipios das <em>Software-Defined Networks</em> (SDN);</li>
<li>Separa o processo em 2 planos:
<ul>
<li><strong>Plano de Dados</strong>;
<ul>
<li>Pedacinhos de <em>middleware</em> entre os diversos pontos. Apenas sabem otimizar o <em>I/O</em>, mas não querem saber do trabalho dos outros pontos.</li>
</ul>
</li>
<li><strong>Plano de Controlo</strong>.
<ul>
<li>Cérebro do armazenamento. Controla a infraestrutura de armazenamento e tem em atenção a sua estrutura, o que permite que tome decisões acerca do que cada <em>stage</em> (do plano de dados) deverá fazer.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="teórica-09"><a class="header" href="#teórica-09">Teórica 09</a></h1>
<h2 id="monitorização"><a class="header" href="#monitorização">Monitorização</a></h2>
<ul>
<li>O monitor é algo que observa a atividade do sistema.
<ul>
<li>O sistema é algo genérico, ou seja, poderá ser 1 CPU, 1 computador, um conjunto de servidores, etc...</li>
</ul>
</li>
</ul>
<h3 id="conceitos"><a class="header" href="#conceitos">Conceitos</a></h3>
<ul>
<li>
<p>Um sistema é constituído por:</p>
<ul>
<li><em>Hardware</em>;</li>
<li>Lógica (programas).</li>
</ul>
</li>
<li>
<p>Estes têm estado!</p>
<ul>
<li>O estado muda com <strong>eventos</strong>!
<ul>
<li>Um evento é uma unidade de monitorização, ou seja, será o nosso objeto de monitorização que será registado em <em>traces</em>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Um <em>trace</em> é um <em>log</em> de eventos.</p>
<ul>
<li>Contém <em>timestamps</em>, detalhes de variáveis, etc...</li>
</ul>
</li>
<li>
<p><strong>Domínio</strong>: exatamente aquilo que queremos observar (métricas que pretendemos estudar);</p>
<ul>
<li>Muitas vezes, o domínio é definido numa abordagem semelhante a tentativa-erro.</li>
</ul>
</li>
<li>
<p><strong>Detalhe</strong>: qual o detalhe que queremos agregar a informação. De notar que isto terá impacto devido ao <em>overhead</em>, ou seja, maior detalhe implicará uma maior carga de trabalho. Varia em:</p>
<ul>
<li><em>input rate</em>: detalhe ao nível temporal (débito ao observar);</li>
<li><em>resolution</em>: até que ponto a aplicação é capaz de representar no <em>input rate</em> que pretendemos (a representar).</li>
</ul>
</li>
</ul>
<h3 id="classificação-do-monitor"><a class="header" href="#classificação-do-monitor">Classificação do Monitor</a></h3>
<ul>
<li>
<p><em>Event-Driven vs Sampling</em>: o que é que dará <em>trigger</em> para se iniciar a observação?</p>
<ul>
<li><em><strong>Event-Driven</strong></em>: monitoriza sempre que um evento ocorra;</li>
<li><em><strong>Sampling</strong></em>: monitoriza de vez em quando, em intervalos aleatórios.</li>
</ul>
</li>
<li>
<p><em>On-line vs Batch</em>: quando é que a observação estará disponível?</p>
<ul>
<li><em><strong>On-line</strong></em>: disponibiliza a observação em tempo real;</li>
<li><em><strong>Batch</strong></em>: disponibiliza a observação de vez em quando, em conjuntos de observações agregados.</li>
</ul>
</li>
<li>
<p><em>Hardware vs Software</em></p>
<ul>
<li><em><strong>Hardware</strong></em>: monitor é implementado em <em>hardware</em>.
<ul>
<li>Muito rápido;</li>
<li>Muito preciso;</li>
<li>Nada flexível, ou seja, não conseguimos alterar o que ele irá monitorizar ou outros parâmetros.</li>
</ul>
</li>
<li><em><strong>Software</strong></em>:
<ul>
<li>Lento;</li>
<li>Mais flexível, visto que somos nós que implementamos o que pretendemos.</li>
</ul>
</li>
<li>Geralmente, utiliza-se o monitor por <em>software</em>.</li>
</ul>
</li>
<li>
<p><em>Centralized vs Distributed</em></p>
</li>
</ul>
<h3 id="arquitetura-de-monitorização"><a class="header" href="#arquitetura-de-monitorização">Arquitetura de Monitorização</a></h3>
<ul>
<li>
<p>Numa aplicação real, o mesmo componente poderá efetuar as funções de diversas camadas lógicas.</p>
</li>
<li>
<p><strong>Camadas Lógicas</strong>:</p>
<ul>
<li><strong>Observação</strong>: observa os eventos o mais perto possível do local em que ocorrem;</li>
<li><strong>Coleção</strong>: coleciona os dados da observação e normaliza-os;</li>
<li><strong>Análise</strong>: aplica filtros, relaciona e sumariza os dados da coleção;</li>
<li><strong>Apresentação</strong>: cria <em>dashboards</em> e outras interfaces de modo a representar os dados ao utilizador.</li>
</ul>
</li>
</ul>
<p><img src="images/arquitetura_monitor.png" alt="image Arquitetura de Monitorização" /></p>
<h4 id="observação"><a class="header" href="#observação">Observação</a></h4>
<ul>
<li>Observação passiva ou <em>spying</em> (p.e. <em>network sniffer</em>);</li>
<li>Instrumentar:
<ul>
<li><em>counters</em> construídos em sistema;</li>
<li>geração de <em>logs</em>.</li>
</ul>
</li>
<li><em>Probing</em> com <em>requests</em> adcionais:
<ul>
<li><em>ping</em></li>
</ul>
</li>
</ul>
<h4 id="coleção"><a class="header" href="#coleção">Coleção</a></h4>
<ul>
<li><em>Push Data vs Pull Data</em>:
<ul>
<li><em><strong>Push Data</strong></em>: Está constantemente a colecionar dados;</li>
<li><em><strong>Pull Data</strong></em>: De vez em quando pede para colecionar dados.</li>
<li>A escolha do tipo de coleção é feita com base na configuração, nas APIs, nos sistemas de <em>legacy</em>, etc...</li>
</ul>
</li>
<li>Resiliência e Persistência de Dados:
<ul>
<li>Por vezes, esta camada é responsável por guardar os dados normalizados para a análise ser feita sobre eles.</li>
</ul>
</li>
<li>É preciso ter em atenção a sincronização de relógios quando este processo é feito em ambientes distribuídos.</li>
</ul>
<h4 id="análise"><a class="header" href="#análise">Análise</a></h4>
<ul>
<li>Tarefa de processamento de dados:
<ul>
<li><em>Time Series</em>;</li>
<li><em>Searching</em>.</li>
</ul>
</li>
<li>É muito importante que esteja bem implementada em ambientes de muito grande escala.
<ul>
<li>Em muitos casos, precisa mesmo de ser distribuída.</li>
</ul>
</li>
</ul>
<h4 id="apresentação"><a class="header" href="#apresentação">Apresentação</a></h4>
<ul>
<li>
<p>Objetivos:</p>
<ul>
<li>Apresentação de métricas de <em>performance</em>;</li>
<li>Deteção de erros;</li>
<li>Dar <em>tracking</em> à configuração.</li>
</ul>
</li>
<li>
<p>Resultados:</p>
<ul>
<li>Geração de alertas;</li>
<li>Representação gráfica.</li>
</ul>
</li>
</ul>
<h3 id="monitorização-e-gestão"><a class="header" href="#monitorização-e-gestão">Monitorização e Gestão</a></h3>
<ul>
<li><strong>Políticas</strong>:
<ul>
<li><strong>Exemplo</strong>: &quot;Se esta VM estiver a utilizar mais que 20% da CPU mata-a&quot;.</li>
</ul>
</li>
<li><strong>Orquestrador</strong>:
<ul>
<li>Gere as políticas;</li>
<li>Através das métricas verifica as políticas e manda atuar em conformidade.</li>
</ul>
</li>
<li><strong>Atuação</strong>:
<ul>
<li>Faz o que o orquestrador lhe ordena.</li>
</ul>
</li>
</ul>
<p><img src="images/monit_gest.png" alt="image Monitorização e Gestão" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="teórica-10"><a class="header" href="#teórica-10">Teórica 10</a></h1>
<h2 id="benchmarking-avaliação"><a class="header" href="#benchmarking-avaliação"><em>Benchmarking</em> (Avaliação)</a></h2>
<ul>
<li>O sistema a ser avaliado é denominado SUT (<em>System Under Test</em>).</li>
<li><strong>Componentes base de uma ferramenta de <em>benchmarking</em></strong>
<ul>
<li><em>Workload</em> (Carga);</li>
<li>Ambiente;</li>
<li>Métricas.</li>
</ul>
</li>
</ul>
<p><img src="images/componentes_benchmarking.png" alt="image Componentes Benchmarking" /></p>
<h3 id="carga"><a class="header" href="#carga">Carga</a></h3>
<ul>
<li>A grande questão reduz-se à quantidade de carga que se deverá induzir ao sistema;</li>
<li>Além disso, surge ainda a questão de qual será a maneira mais correta de induzir carga ao sistema. Para esta questão, tem-se diversas opções:
<ul>
<li>Colocar a alicação em produção e testar lá;
<ul>
<li>No entanto, geralmente, não queremos testar com a aplicação já em produção.</li>
</ul>
</li>
<li>Utilizar dados e pedidos que simulam ações reais dos utilizadores. A isto é chamado <em>trace</em>;
<ul>
<li>É difícil ter um <em>trace</em> real da aplicação;</li>
<li>É difícil de escalar.</li>
</ul>
</li>
<li>Gerar pedidos sintéticos.
<ul>
<li>Seleciona um subconjunto de operações;</li>
<li>Gera parâmetros aleatórios;
<ul>
<li>Não uniformes (<code>Zipf</code>).</li>
</ul>
</li>
<li>Agenda pedidos;
<ul>
<li>Concorrentes;</li>
<li>Com tempo <em>inter-arrival</em> (exponencial).</li>
</ul>
</li>
<li>O problema desta abordagem é que é tudo artificial...</li>
</ul>
</li>
</ul>
</li>
<li>A escolha da maneira que deve induzir carga irá depender daquilo que queremos testar e da aplicação em questão.</li>
</ul>
<h3 id="ambiente"><a class="header" href="#ambiente">Ambiente</a></h3>
<ul>
<li>Devemos perceber o que temos a nível de <em>hardware</em> e <em>software</em> no ambiente em que estamos a testar.
<ul>
<li>Devemos perguntar o ambiente que está a ser utilizado fará sentido para uma utilização da aplicação em produção.</li>
</ul>
</li>
</ul>
<h3 id="métricas"><a class="header" href="#métricas">Métricas</a></h3>
<ul>
<li>Existem múltiplos tipos de métrica, poderá ser o desempenho da velocidade de resposta, se as respostas dadas pelo sistemas estão corretas, etc...</li>
</ul>
<h4 id="desempenho-1"><a class="header" href="#desempenho-1">Desempenho</a></h4>
<ul>
<li><strong>Tempo de Resposta</strong> (latência): intervalo entre os pedidos do utilizador e a resposta do sistema;
<ul>
<li>À medida que se vai aumentando a carga, é expectável que a latência aumente.</li>
</ul>
</li>
<li><strong>Débito</strong>: taxa a que os pedidos são respondidos (p.e. &quot;consegue responder a 30 pedidos por segundo&quot;).</li>
</ul>
<p><strong>Atenção</strong>: o débito e a latência não são, necessariamente, inversos. Isto só acontece quando o sistema estiver 100% ocupado e for sequencial.</p>
<h4 id="outras-métricas"><a class="header" href="#outras-métricas">Outras métricas</a></h4>
<ul>
<li><strong>Utilização</strong>:
<ul>
<li>Recursos (p.e. CPU, RAM, Rede, Disco).</li>
</ul>
</li>
<li><strong>Eficiência</strong>:
<ul>
<li>Rácio entre o débito e a utilização.</li>
</ul>
</li>
<li><strong>Resiliência</strong>:
<ul>
<li>Erros.</li>
</ul>
</li>
<li><strong>Disponibilidade</strong>:
<ul>
<li><em>Uptime vs Downtime</em>.</li>
</ul>
</li>
</ul>
<h3 id="medições"><a class="header" href="#medições">Medições</a></h3>
<ul>
<li>Não podemos representar todas as amostras num único número?
<ul>
<li>Por exemplo, na média? Depende do que queremos! A média pode enganar devido a picos;</li>
<li>Por exemplo, no desvio padrão? Depende do que queremos! Pode enganar e termos uma perceção errada do sistema...</li>
</ul>
</li>
</ul>
<h4 id="amostras-vs-tempo"><a class="header" href="#amostras-vs-tempo">Amostras <em>vs</em> Tempo</a></h4>
<ul>
<li>Devemos representar cada amostra de forma individual.</li>
</ul>
<p><img src="images/amostras_vs_tempo.png" alt="image Amostras vs Tempo" /></p>
<h4 id="amostras-vs-frequência"><a class="header" href="#amostras-vs-frequência">Amostras <em>vs</em> Frequência</a></h4>
<ul>
<li>Representar a frequência de cada resultado;</li>
<li>Utilizar histogramas;
<ul>
<li>Permitir analisar modas, simetrias, etc...</li>
</ul>
</li>
<li><em>Empirical Cumulative Distribution Function</em> (ECDF);
<ul>
<li>Permite analisar médias, percentis, quartis, etc...</li>
</ul>
</li>
</ul>
<p><img src="images/ecdfs.png" alt="image ECDFs" /></p>
<ul>
<li>As ECDFs permitem ainda termos uma comparação direta entre distribuições, bastando juntar as ECDFs de ambas num único gráfico.</li>
</ul>
<h5 id="padrões-das-ecdfs"><a class="header" href="#padrões-das-ecdfs">Padrões das ECDFs:</a></h5>
<p><em><strong>Long Tail</strong></em>: Causado por, por exemplo, paragens no <em>garbage collector</em>.</p>
<p><img src="images/longtail.png" alt="image Long Tail" /></p>
<p><em><strong>Bimodal</strong></em>: causado, por exemplo, por <em>if statements</em>.</p>
<p><img src="images/bimodal.png" alt="image Bimodal" /></p>
<h4 id="conclusões-da-amostragem"><a class="header" href="#conclusões-da-amostragem">Conclusões da Amostragem</a></h4>
<ul>
<li>Permitem ver médias, modas, medianas ou grandes percentis;</li>
<li>Permitem medir o intervalo de confiança (CI);</li>
<li>Permitem medir o coeficiente de variação (CV).
<ul>
<li>\[ \frac{desvio\ padrao}{media} \], geralmente, expresso em %.</li>
</ul>
</li>
</ul>
<h3 id="ferramentas"><a class="header" href="#ferramentas">Ferramentas</a></h3>
<ul>
<li>Existem ferramentas que permitem gerar carga e amostragens;</li>
<li>Além disso, podemos também utilizar ferramentas para a análise de dados.</li>
</ul>
<h3 id="erros-comuns"><a class="header" href="#erros-comuns">Erros Comuns</a></h3>
<ul>
<li>Não ter objetivos ou ter objetivos enviesados;</li>
<li>Ter uma abordagem não sistemática;
<ul>
<li>Devemos ter <em>scripts</em> de tudo, correr sempre tudo no mesmo ambiente, correr múltiplas vezes os mesmos testes, etc...</li>
</ul>
</li>
<li>Cargas de trabalho não representativas da utilização real da aplicação;</li>
<li>Fazer uma análise à apresentação de resultados incorreta.</li>
</ul>
<h3 id="conclusões"><a class="header" href="#conclusões">Conclusões</a></h3>
<ul>
<li>Existem múltiplas dimensões para a avaliação de um sistema;</li>
<li>Para avaliar um sistema, devemos:
<ul>
<li>Avaliar ao longo do tempo;</li>
<li>Ter em conta que o sobreaquecimento de componentes pode acontecer;</li>
<li>Repetir, múltiplas vezes, os mesmos testes.</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
